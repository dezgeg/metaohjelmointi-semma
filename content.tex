\section{Johdanto}
\section{Haskell}
\subsection{Yleistä}
Haskell on staattisesti- ja vahvasti tyypitetty laiska, puhtaasti funktionaalinen ohjelmointikieli.

Haskell-kielen suunnittelu ja kehitys alkoi vuonna 1987,
jolloin päämääränä oli tuoda lukuisten, hyvin samankaltaisten laiskojen puhtaasti funktionaalisten tutkimuskielien ideat yhteen.
Tällä hetkellä kielen uusin spesifikaatio ``Haskell Language Report'' on vuodelta 2010.~\cite{HaskellReport2010}.

Aktiivisesti kehitettyjä sekä ajantasaisia Haskell-kääntäjiä on käytännössä ainoastaan
GHC, Glasgow Haskell Compiler~\cite{GHC}.
Itse kielen käyttäjiä varten julkaistaan säännöllisesti Linux-, Windows- ja
Mac OS X-käyttöjärjestelmille  jakelupaketti ``Haskell Platform''~\cite{HaskellPlatform},
joka sisältää GHC:n lisäksi kirjastoja esimerkiksi yksikkötestaukseen, POSIX-rajapintoihin
sekä OpenGL:ään.

Haskellin syntaksi poikkeaa suhteellisen paljon muista yleisesti käytetyistä ohjelmointikielistä.
Listauksessa \ref{lst:first-example} on esimerkki,
joka kysyy käyttäjältä nimeä ja tervehtii käyttäjää.

\begin{listing}[H]
    \inputminted{haskell}{codes/FirstExample.hs}
    \label{lst:first-example}
    \caption{Yksinkertainen Haskell-esimerkki.}
\end{listing}

Esimerkistä selviää muun muassa, että lohkorakenteita ei ole ilmaistu muulla kuin sisennyksellä,
eikä lausekkeiden loppuun tarvitse laittaa päätemerkkiä (kuten puolipistettä).
Välilyönnit ja rivinvaihdot ovat siis Haskellissa merkityksellisiä.
Myöskin erikoista muihin staattisesti tyypitettyihin ohjelmointikieliin verrattaessa on,
ettei koko ohjelmassa ole yhtään tyyppimäärittelyä.
Haskellin tyyppijärjestelmä perustuu nk. Hindley-Milner-tyyppijärjestelmään~\cite{Hindley,Milner},
joka mahdollistaa sekä muuttujien että funktioiden automaattisen tyyppienpäättelyn useimmissa tapauksissa.
Funktiokutsun syntaksi eroaa myös yleisesti käytetystä notaatiosta;
Haskellissa funktiokutsussa ei käytetä sulkeita (paitsi lausekkeiden ryhmittelyyn) ja parametrit erotetaan vain välilyönneillä.
Taulukossa \ref{tbl:function-call-examples} on joitakin selventäviä esimerkkejä syntaksien eroista.

\begin{table}
    \begin{tabular}[H]{c|c}
        Java                    &   Haskell         \\
        \hline
        \texttt{f()}            &   \texttt{f}              \\
        \texttt{f(x, y, z)}     &   \texttt{f x y z}        \\
        \texttt{f(x(a), y(t))}  &   \texttt{f (x a) (y t)}  \\
    \end{tabular}
    \label{tbl:function-call-examples}
    \caption{Esimerkkejä Javan ja Haskellin funktiokutsusyntaksin eroista.}
\end{table}

\subsection{Operaattorit}
Haskellissa kaikkia nimettyjä funktioita voi vaihtoehtoisesti käyttää binäärioperaattorina ympäröimällä funktion nimi kenohipsuilla (\texttt{`}):
\begin{minted}{haskell}
divides m n = n `mod` m == 0
\end{minted}

Toisin kuin monissa muissa operaattoreille infiksisyntaksia käyttävissä ohjelmointikielissä,
Haskellissa käytettävissä olevia operaattoreita ei ole erikseen kovakoodattu kieleen,
vaan ohjelmoija voi itse määritellä mielivaltaisia operaattoreita.

\begin{listing}[H]
\begin{minted}{haskell}
(x1, y1) <+> (x2, y2) = (x1 + x2, y1 + y2)
(x, y) .* k = (k * x, k * y)
infixl 6 <+>
infixl 7 .*
\end{minted}
\label{lst:operators-example}
\caption{Esimerkki omien operaattoreiden määrittelystä.}
\end{listing}

Listauksessa \ref{lst:operators-example} määritellään kaksiuloitteisen vektorin yhteenlaskua
ja skalaarilla kertomista vastaavat operaattorit \Haskell{<+>} ja \Haskell{.*}.
Myös operaattoreiden sidontajärjestys on ohjelmoijan valittavissa;
avainsanoilla \Haskell{infixl}, \Haskell{infixr} ja \Haskell{infix} määritellään sekä
operaattoreiden suhteellinen prioriteetti (kokonaislukuna 0--9, pienempi sitoo tiukemmin) että
samanprioriteettisten operaattoreiden laskemissuunta
(vasemmalta oikealle, oikealta vasemmalle tai ei sallittu).
Siis listauksen \ref{lst:operators-example} operaattoreita käyttäen olisi lauseke
\Haskell{(1, 2) <+> 3 .* (4, 5)} tulkittavissa perinteisten matemaattisten operaattorien tapaan,
eli \Haskell{(1, 2) <+> (3 .* (4, 5))}.

\subsection{Funktioiden lähempää tarkastelua}
Kuten aiemmissa luvuissa on nähty,
Haskellin funktiotyypin ja funktiokutsun syntaksi poikkeaa paljon muista ohjelmointikielistä.
Esimerkiksi Javassa hypoteettisen \texttt{charAt}-funktion tyypin syntaksi on

\begin{itemize}
    \item funktion tyyppi: \texttt{char charAt(String str, int index)}
    \item funktiokutsu: \texttt{charAt("foo", 0)}
\end{itemize}
Haskellissa taasen:
\begin{itemize}
    \item funktion tyyppi: \Haskell{charAt :: String -> Int -> Char}
    \item funktiokutsu: \Haskell{charAt "foo"\, 0}
\end{itemize}

Isoimpana erona Javaan verrattuna on, että Haskellissa funktion paluuarvo tulee loppuun eikä alkuun,
ja funktiokutsussa sulkeita ei tarvita.
Tämä ero ei ole tehty muiden ohjelmointikielten käyttäjien hämäämiseksi,
vaan tällä syntaksivalinnalla voidaan yksinkertaistaa kieltä.
Nimittäin edellä esitetty funktiotyyppi- ja kutsu tulkitaan Haskellissa seuraavasti:

\begin{minted}{haskell}
charAt :: String -> (Int -> Char)
(charAt "foo") 0
\end{minted}

Selviääkin, että Haskellin ainoa funktiotyyppi on yksiparametrinen funktio,
ja useampiparametriset funktiot on toteutettu funktioina, jotka palauttavat toisia funktioita.
Eli siis selvennettynä,
\Haskell{charAt} onkin funktio, joka ottaa \Haskell{String}:n ja palauttaa funktion,
joka ottaa \Haskell{Int}:n ja palauttaa \Haskell{Char}:n.

\subsection{Osittainsovellus}
Edellisessä luvussa esitellyillä funktioiden ominaisuuksilla on muutakin etua
kuin kielen yksinkertaistaminen; niiden avulla ohjelmia voi lyhentää tietyissä tilanteissa.
Tarkastellaan seuraavaksi \Haskell{filterPositives}-funktiota, joka poistaa listasta kaikki
epäpositiiviset luvut.
Perinteinen tapa kirjoittaa kyseinen funktio näyttää tältä:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives luvut = filter (\x -> x > 0) luvut
\end{minted}

Edellisen voi kuitenkin kirjoittaa hieman lyhyemmin käyttämällä osittain soveltamista
(engl. partial application) seuraavasti:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (\x -> x > 0)
\end{minted}

Kun kaksiparametriselle funktiolle \Haskell{filter} annetaan vain yksi kiinteä parametri,
tulee lausekkeen arvoksi yksiparametrinen funktio,
joka paluuarvonaan kutsuu \Haskell{filter}:iä sekä kiinteällä parametrillä että puuttuvalla parametrilla.

Haskellissa on myös syntaksisokeria binäärioperaattorien osittain soveltamiselle.
Mielivaltaiselle binäärioperaattorille \Haskell{@}:
\begin{itemize}
    \item \Haskell{(@ lauseke)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> x @ lauseke)}
    \item \Haskell{(lauseke @)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> lauseke @ x)}
\end{itemize}

Tämän avulla voidaan \Haskell{filterPositives}-esimerkkiä lyhentää vielä lisää:
\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (>0)
\end{minted}

\subsection{Laiskuus}

Haskell on \emph{laiskasti evaluoitu} ohjelmointikieli,
joka tarkoittaa että Haskellissa lausekkeen arvoa ei evaluoida ennen kuin sitä tarvitaan.
Seuraava ohjelmaesimerkki havainnollistaa asiaa:

\begin{listing}[H]
    \inputminted{haskell}{codes/Laziness.hs}
    \label{lst:laziness}
    \caption{\texttt{Laziness.hs:} Esimerkki laiskasta evaluaatiosta}
\end{listing}

Listauksessa \ref{lst:laziness} \Haskell{nums}-niminen lista on alustettu arvoilla,
jotka ei-laiskassa ohjelmointikielissä aiheuttaisivat virheen jo listan alustusrivillä:
listan ensimmäisen alkion alustuksessa jaetaan nollalla ja kolmannennen alkion
alustus päätyy ikuiseen rekursioon.
Haskell-ohjelman tulostuksista voidaan sen sijaan nähdä,
että siitä huolimatta \Haskell{nums}-listaa voidaan käsitellä varsin monella
tavoin ilman suorituksen keskeytymistä tai jumiutumista.
Myöskään muuttujan \Haskell{divByZeroPlusOne} luominen ei kaada ohjelmaa,
vaan vasta \Haskell{print}-funktion kutsuminen aiheuttaa lausekkeen
\Haskell{1 `div` 0} evaluoinnin, jolloin ohjelman suoritus päättyy
eikä viimeistä tulostusta tapahdu.

\subsection{Syntaksi ja määrittelyt}
\subsection{Sisäänrakennetut tyypit}
\subsection{Kontrollirakenteet}
\subsection{Omien tyyppien määrittely}
\subsection{Tyyppiluokat}

\section{Metaohjelmointi Haskellilla}
\subsection{Template Haskell}

Template Haskell~\cite{ThPaper} on GHC-kääntäjän toteuttama epävirallinen laajennos Haskell-kieleen,
joka tarjoaa mahdollisuudet käännösaikaiseen metaohjelmointiin makrojen muodossa.

Makrojärjestelmät voidaan karkeasti jakaa tekstuaalisiin makroihin sekä syntaktisiin makroihin.
Tunnetuimpia esimerkkejä tekstuaalisista makroista on C-kielen esikääntäjä sekä erinäisten assemblereiden makrokielet,
kun taas syntaktiset makrot ovat Lisp-kieliperheen tavaramerkki.
Template Haskellin tarjoamat makrot lukeutuvat näistä kategorioista jälkimmäiseen:
Template Haskell-makrot ovat tavallisia Haskell-funktioita,
joilla on paluutyyppinä Template Haskell-kirjastossa määritelty syntaksipuutyyppi.

\subsection{Template Haskell-esimerkki}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/THExample.hs}
    \label{lst:example-definition}
    \caption{\texttt{THExample.hs:} Esimerkki Template Haskell-makrosta}
\end{listing}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/Main.hs}
    \label{lst:example-usage}
    \caption{\texttt{Main.hs:} Esimerkki edeltävän makron käytöstä}
\end{listing}

Listauksessa \ref{lst:example-definition} määritellään makro \Haskell{compileTimeEval},
jonka avulla voidaan tehdä laskutoimituksia käännösaikana.
Huomattavaa on, että koko kyseinen moduuli on aivan standardia Haskell 2010-koodia,
ja että \Haskell{compileTimeEval} on vain tavallinen Haskell-funktio,
jonka paluutyyppinä sattuu olemaan \Haskell{Q Exp}.

Listauksessa \ref{lst:example-usage} esitellään \Haskell{compileTimeEval}-makron käyttöä,
määrittelemällä nimet \Haskell{foo} ja \Haskell{bar} sen avulla.
Makron käyttö tapahtuu dollarimerkkisyntaksilla \Haskell{\$(\emph{lauseke})},
jossa \emph{lauseke} voi olla mielivaltaista Haskell-koodia.
Koska dollarisyntaksi ja Template Haskell itsessään ei kuulu Haskell 2010-standardiin,
on moduulin alkuun täytynyt laittaa pragma \Haskell{\{-\# LANGUAGE TemplateHaskell \#-\}}
Template Haskell-laajennoksen sallimiseksi.

Kääntäessä \Haskell{Main.hs}-moduulia voidaan havaita,
että \Haskell{\$(compileTimeEval ...)}-lausekkeiden arvot todella lasketaan käännösaikana:
ensin useita sekunteja kuluu lukujen 1--10 000 000 summan laskemiseen,
sitten käännös päättyy virheeseen,
koska makroekspansion aikana jaettiin nollalla.
Siis \Haskell{\$()}-rakenteen sisällä oleva lauseke suoritetaan käännösaikana,
ja sen paluuarvona oleva syntaksipuu (tyyppiä \Haskell{Q Exp}) liitetään käännettävän moduulin
syntaksipuuhun.
Template Haskellin moduuli \Haskell{Language.Haskell.TH.Syntax} tarjoaa tyypit \Haskell{Exp},
joka vastaa Haskellin lausekkeen syntaksipuun tyyppiä,
sekä tyypin \Haskell{Q},
joka on \Haskell{IO}-tyyppiin verrattavissa oleva monadityyppi.
Moduulista \Haskell{Language.Haskell.TH.Lib} löytyvät apufunktiot \Haskell{litE :: Lit -> Q Exp}
sekä \Haskell{litE :: Integer -> Lit},
joiden avulla luodaan kokonaislukuliteraalia vastaava syntaksipuun lehtisolmu.

\subsection{Syntaksipuu}
Koska Template Haskell-makrojen pääasiallinen tavoite on tuottaa koodia syntaksipuun muodossa,
on syntaksipuuta vastaavat Haskell-tietorakenteet erittäin keskeisessä osassa.
Kyseiset tietotyypit löytyvät kirjastomoduulista \Haskell{Language.Haskell.TH.Syntax}.

Tyyppi \Haskell{Exp} vastaa Haskell-lausekkeen syntaksipuuta.

\begin{minted}{haskell}
data Exp
  = VarE Name                          -- viittaus arvon nimeen, esim. foo
  | ConE Name                          -- viittaus tyyppikonstruktorin nimeen, esim. True
  | LitE Lit                           -- vakio, esim. 'a', 42 tai "mjono"
  | AppE Exp Exp                       -- funktiokutsu, esim. f x

  | InfixE (Maybe Exp) Exp (Maybe Exp) -- operaattorin kutsu tai osittainsovellus, esim:
                                       -- a + b, (+b), (a+)

  | UInfixE Exp Exp Exp                -- ???

  | ParensE Exp                        -- lauseke suluissa, esim. (x)
  | LamE [Pat] Exp                     -- lambdafunktio, \ p1 p2 -> e
  | LamCaseE [Match]                   -- case m1; m2
  | TupE [Exp]                         -- monikon muodostus, esim. (e1, e2)
  | CondE Exp Exp Exp                  -- ehtolauseke, if e1 then e2 else e3
  | LetE [Dec] Exp                     -- sitomislauseke let x=e1; y=e2 in e3
  | CaseE Exp [Match]                  -- case-lauseke: case e of m1; m2
  | DoE [Stmt]                         -- do-lauseke: do { p <- e1; e2 }
  | CompE [Stmt]                       -- ei kasitella!!! @{ [ (x,y) | x <- xs, y <- ys ] }@

  | ArithSeqE Range                    -- ei kasitella!!! @{ [ 1 ,2 .. 10 ] }@
  | ListE [Exp]                        -- lista [e1, e2, e3]
  | SigE Exp Type                      -- ei kasitella!!! @{ e :: t }@
  | RecConE Name [FieldExp]            -- ei kasitella!!! @{ T { x = y, z = w } }@
  | RecUpdE Exp [FieldExp]             -- ei kasitella!!! @{ (f x) { z = w } }@
  deriving( Show, Eq, Data, Typeable )
\end{minted}
