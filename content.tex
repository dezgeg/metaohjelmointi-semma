\section{Johdanto}
\section{Haskell}
\subsection{Yleistä}
Haskell on staattisesti- ja vahvasti tyypitetty laiska, puhtaasti funktionaalinen ohjelmointikieli.

Haskell-kielen suunnittelu ja kehitys alkoi vuonna 1987,
jolloin päämääränä oli tuoda lukuisten, hyvin samankaltaisten laiskojen puhtaasti funktionaalisten tutkimuskielien ideat yhteen.
Tällä hetkellä kielen uusin spesifikaatio ``Haskell Language Report'' on vuodelta 2010~\cite{HaskellReport2010}.

Aktiivisesti kehitettyjä sekä ajantasaisia Haskell-kääntäjiä on käytännössä ainoastaan
GHC, Glasgow Haskell Compiler~\cite{GHC}.
Itse kielen käyttäjiä varten julkaistaan säännöllisesti Linux-, Windows- ja
Mac OS X-käyt\-tö\-jär\-jes\-tel\-mille  jakelupaketti ``Haskell Platform''~\cite{HaskellPlatform},
joka sisältää GHC:n lisäksi kirjastoja esimerkiksi yksikkötestaukseen, POSIX-rajapintoihin
sekä OpenGL:ään.

Haskellin syntaksi poikkeaa suhteellisen paljon muista yleisesti käytetyistä ohjelmointikielistä.
Listauksessa \ref{lst:first-example} on esimerkki,
joka kysyy käyttäjältä nimeä ja tervehtii käyttäjää.

\begin{listing}[H]
    \inputminted{haskell}{codes/FirstExample.hs}
    \label{lst:first-example}
    \caption{Yksinkertainen Haskell-esimerkki.}
\end{listing}

Esimerkistä selviää muun muassa, että lohkorakenteita ei ole ilmaistu muulla kuin sisennyksellä,
eikä lausekkeiden loppuun tarvitse laittaa päätemerkkiä (kuten puolipistettä).
Välilyönnit ja rivinvaihdot ovat siis Haskellissa merkityksellisiä.
Myöskin erikoista muihin staattisesti tyypitettyihin ohjelmointikieliin verrattaessa on,
ettei koko ohjelmassa ole yhtään tyyppimäärittelyä.
Haskellin tyyppijärjestelmä perustuu nk. Hindley-Milner-tyyppijärjestelmään~\cite{Hindley,Milner},
joka mahdollistaa sekä muuttujien että funktioiden automaattisen tyyppienpäättelyn useimmissa tapauksissa.
Funktiokutsun syntaksi eroaa myös yleisesti käytetystä notaatiosta;
Haskellissa funktiokutsussa ei käytetä sulkeita (paitsi lausekkeiden ryhmittelyyn) ja parametrit erotetaan vain välilyönneillä.
Taulukossa \ref{tbl:function-call-examples} on joitakin selventäviä esimerkkejä syntaksien eroista.

\begin{table}
    \begin{tabular}[H]{l|l}
        Java                    &   Haskell         \\
        \hline
        \texttt{f()}            &   \texttt{f}              \\
        \texttt{f(x, y, z)}     &   \texttt{f x y z}        \\
        \texttt{f(x(a), y(t))}  &   \texttt{f (x a) (y t)}  \\
    \end{tabular}
    \label{tbl:function-call-examples}
    \caption{Esimerkkejä Javan ja Haskellin funktiokutsusyntaksin eroista.}
\end{table}

\subsection{Perustyyppejä ja kontrollirakenteita}
Haskellista löytyy kaksi kokonaislukutyyppiä: \Haskell{Int},
jonka lukualue on rajallinen (toteutuksesta riippuen, kuitenkin vähintään 30 bittiä)
sekä \Haskell{Integer},
jonka lukualue on rajaton.
Liukulukutyyppeinä löytyy \Haskell{Float} ja \Haskell{Double},
jotka vastaavat lähes kaikkien muidenkin ohjelmointikielten käyttämiä IEEE~754- standardin mukaisia liukulukuja.
Kaikille lukuliteraaleille syntaksi on samanlainen kuin Javassa.
Totuusarvojen tyyppi on \Haskell{Bool},
mutta yleisestä käytännöstä poiketen itse totuusarvot ovat \Haskell{True} ja \Haskell{False} isoilla alkukirjaimilla.
Tälle erolle kirjainkoossa on itse asiassa syy; Haskellissa nimen ensimmäisen alkukirjaimen kirjainkoolla on merkitystä
ja sekä tyyppien että vakioiden nimien täytyy alkaa isolla alkukirjaimella.

Useista imperatiivisista kielistä poiketen \Haskell{if-then-else}-konstruktio ei ole lause (statement),
vaan lauseke (expression).
Siis \Haskell{if} palauttaa aina arvon, mikä tarkoittaa myös että \Haskell{else}-haara on aina pakollinen.

\begin{minted}{haskell}
henkilonKuvaus ika = if ika < 18
                        then "Lapsi"
                        else "Aikuinen"
luvunKuvaus n = "Luku on " ++ (if n < 0 then "negatiivinen" else "positiivinen")
\end{minted}

Useamman kuin yhden ehdon vertailulle on oma syntaksinsa.

\begin{minted}{haskell}
fizzbuzz n | n % 15 == 0 = "FizzBuzz"
           | n % 3  == 0 = "Fizz"
           | n % 5  == 0 = "Buzz"
           | otherwise   = show n
\end{minted}

Koska Haskell on puhtaasti funktionaalinen ohjelmointikieli,
ei muuttujan arvon muuttaminen ole mahdollista.
Näin ollen kielessä ei myöskään ole ollenkaan silmukoita kontrollirakenteina,
vaan niiden tilalla on käytettävä rekursiota.
Esimerkiksi kertomafunktio voitaisiin toteuttaa seuraavasti:

\begin{minted}{haskell}
factorial n | n == 0    = 1
            | otherwise = n * factorial (n - 1)
\end{minted}

Kun käytetään rekursiota silmukan korvikkeena,
on oltava tarkkana rekursiokutsujen viemän pinokehyksien tilamäärän kanssa.
Esimerkiksi edellisen esimerkin \Haskell{factorial}-funktio on epätehoton ja käyttää lineaarisen määrän muistia.
Monet rekursiiviset funktiot on kuitenkin apufunktion avulla mahdollista kirjoittaa siten,
että ne käyttävät vakiomäärän muistia.
Koska tällaisia apufunktion vaativia tilanteita tulee Haskellissa vastaan usein,
voi \Haskell{where}-avainsanalla tehdä paikallisia muuttujien- ja funktioiden määrittelyjä.

\begin{minted}{haskell}
factorial n = fac' n 1
    where fac' n acc | n == 0    = acc
                     | otherwise = fac' (n - 1) (n * acc)
\end{minted}

Edellisessä esimerkissä funktion \Haskell{fac'} näkyvyys on ainoastaan \Haskell{factorial}-funktion sisällä.

\subsection{Hahmonsovitus}
Hahmonsovituksen (pattern matching) voidaan katsoa olevan laajennettu versio esimerkiksi javan \texttt{switch}-lauseesta.
Eräs tapa käyttää hahmonsovitusta Haskellissa on \Haskell{case}-lauseke:
\begin{minted}{haskell}
fibonacci n = case n of
                1 -> 1
                2 -> 1
                _ -> fibonacci (n - 1) + fibonacci (n - 2)
\end{minted}
Edellisessä esimerkissä parametriä \Haskell{n} verrataan järjestyksessa hahmoihin \Haskell{1}, \Haskell{2} ja \Haskell{\_},
ja suoritus jatkuu siltä riviltä, jolla vertailu onnistui.
Hahmo \Haskell{\_} on ``wildcard'' eli arvon vertailu hahmoon onnistuu aina.

Koska hahmonsovitusta käytetään Haskellissa paljon, on sille lyhyempi syntaksi olemassa:
hahmonsovitusta voi tehdä suoraan funktion parametrilistassa:

\begin{minted}{haskell}
fibonacci 1 = 1
fibonacci 2 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
\end{minted}

\subsection{Listat}

Kuten muissakin funktionaalisen paradigman ohjelmointikielissä,
Haskellissa perustietorakenne tiedon säilömiseen on linkitetty lista eikä taulukko.
Listan tyyppi kirjoitetaan hakasulkeilla, esimerkiksi tyyppi \Haskell{[Integer]} on lista kokonaislukuja.
Haskellissa ei ole erikseen tietotyyppiä merkkijonoille,
vaan \Haskell{String} on alias tyypille \Haskell{[Char]},
jossa \Haskell{Char}-tyyppi vastaa Unicode-merkkiä.

Listaliteraalin voi luoda laittamalla alkiot hakasulkujen sisään pilkulla erotettuina.
Merkkijonoliteraali on vain erikoissyntaksi \Haskell{Char}-listalle.
\begin{minted}{haskell}
luvut = [1, 2, 3]
mjono1 = "foo"           -- tyyppi [Char]
mjono2 = ['f', 'o', 'o'] -- tyyppi [Char], sama kuin mjono1
\end{minted}

Linkitetyn listan toteutus esimerkiksi Javassa on tyypillisesti solmuluokka,
joka sisältää yhtenä kenttänä listan alkion ja toisena kenttänä viitteen seuraavaan solmuun.
Haskellissa listasolmua vastaa nk. cons-operaattori \Haskell{:}, joka voidaan
mieltää operaattorina joka lisää olemassa olevan listan alkuun yhden alkion.
Esimerkiksi \Haskell{[1, 2, 3]} cons-operaattorin avulla ilmaistuna on \Haskell{1:2:3:[]},
tai täysin sulutettuna \Haskell{1:(2:(3:[]))}.
\Haskell{:}-operaattori on myös samalla \emph{tyyppikonstruktori},
mikä tarkoittaa että sitä voidaan käyttää hahmonsovituksessa.

\begin{minted}{haskell}
length []     = 0
length (_:xs) = 1 + length xs

containsElement []     elem = False
containsElement (x:xs) elem | x == elem = True
                            | otherwise = containsElement xs elem
\end{minted}

\subsection{Anonyymit funktiot}
Anonyymi funktio muodostetaan kenoviivalla (\texttt{\textbackslash}), jota seuraa
parametrilista, nuoli (\texttt{->}), ja lopuksi funktion runko.
Semanttisesti anonyymien funktioiden ja tavallisten funktioiden välillä ei ole mitään eroa.
\begin{minted}{haskell}
square = \x -> x * x

fiveSquared = square 5 -- => 25
\end{minted}
Haskellissa funktiot ovat tavallisia arvoja (functions as first-class values);
niitä voi esimerkiksi antaa funktion parametreinä sekä palauttaa funktioista.
Anonyymien funktioiden avulla sulkeumien luominen on mahdollista.

\begin{minted}{haskell}
callTwice :: (a -> a) -> a -> a
callTwice f x = f (f x)

makeAdder :: Int -> (Int -> Int)
makeAdder amount = \x -> x + amount

increment = makeAdder 1

main = do
    print (callTwice (\x -> 10 * x) 5) -- => 500
    print (increment 5)                -- => 6
\end{minted}
Anonyymit funktiot ovat erityisen käytännöllisiä seuraavissa useimmin käytetyissä listaoperaatioissa:
\begin{itemize}
    \item \Haskell{map :: (a -> b) -> [a] -> [b]} - ottaa funktion ja listan, kutsuu annettua funktiota listan kaikille alkioille
    \item \Haskell{filter :: (a -> Bool) -> [a] -> [a]} - ottaa predikaattifunktion ja listan, palauttaa listasta ne alkiot, joille predikaatti pätee
\end{itemize}
\begin{minted}{haskell}
-- kasvata jokaista lukua sadalla
map (\x -> x + 100) [1, 2, 3] -- => [101, 102, 103]
-- isonna koko merkkijonon kirjainkoko
map (toUpper) "Foo" -- => "FOO"
-- valitse listasta vain b:lla alkavat sanat
filter (\str -> str !! 0 == 'b') ["foo", "bar", "baz", "quux", "biff"]
    -- => ["bar", "baz", "biff"]
\end{minted}

\subsection{Operaattorit}
Haskellissa kaikkia nimettyjä funktioita voi vaihtoehtoisesti käyttää binäärioperaattorina ympäröimällä funktion nimi kenohipsuilla (\texttt{`}):
\begin{minted}{haskell}
divides m n = n `mod` m == 0
\end{minted}

Toisin kuin monissa muissa operaattoreille infiksisyntaksia käyttävissä ohjelmointikielissä,
Haskellissa käytettävissä olevia operaattoreita ei ole erikseen kovakoodattu kieleen,
vaan ohjelmoija voi itse määritellä mielivaltaisia operaattoreita,
ja operaattoreiden sidontajärjestys on myös ohjelmoijan valittavissa.
Operaattorin määritys avainsanoilla \Haskell{infixl}, \Haskell{infixr} ja \Haskell{infix} määritellään sekä
operaattoreiden suhteellinen prioriteetti (kokonaislukuna 0--9, pienempi sitoo tiukemmin) että
samanprioriteettisten operaattoreiden laskemissuunta
(vasemmalta oikealle, oikealta vasemmalle tai ei sallittu).

\begin{listing}[H]
\begin{minted}{haskell}
(x1, y1) <+> (x2, y2) = (x1 + x2, y1 + y2)
(x, y) .* k = (k * x, k * y)
infixl 6 <+>
infixl 7 .*
\end{minted}
\label{lst:operators-example}
\caption{Esimerkki omien operaattoreiden määrittelystä.}
\end{listing}

Listauksessa \ref{lst:operators-example} määritellään kaksiuloitteisen vektorin yhteenlaskua
ja skalaarilla kertomista vastaavat operaattorit \Haskell{<+>} ja \Haskell{.*}.
Siis listauksen \ref{lst:operators-example} operaattoreita käyttäen olisi lauseke
\Haskell{(1, 2) <+> 3 .* (4, 5)} tulkittavissa perinteisten matemaattisten operaattorien tapaan,
eli \Haskell{(1, 2) <+> (3 .* (4, 5))}.

\iffalse
\subsection{Funktioiden lähempää tarkastelua}
Kuten aiemmissa luvuissa on nähty,
Haskellin funktiotyypin ja funktiokutsun syntaksi poikkeaa paljon muista ohjelmointikielistä.
Esimerkiksi Javassa hypoteettisen \texttt{charAt}-funktion tyypin syntaksi on

\begin{itemize}
    \item funktion tyyppi: \texttt{char charAt(String str, int index)}
    \item funktiokutsu: \texttt{charAt("foo", 0)}
\end{itemize}
Haskellissa taasen:
\begin{itemize}
    \item funktion tyyppi: \Haskell{charAt :: String -> Int -> Char}
    \item funktiokutsu: \Haskell{charAt "foo"\, 0}
\end{itemize}

Isoimpana erona Javaan verrattuna on, että Haskellissa funktion paluuarvo tulee loppuun eikä alkuun,
ja funktiokutsussa sulkeita ei tarvita.
Tämä ero ei ole tehty muiden ohjelmointikielten käyttäjien hämäämiseksi,
vaan tällä syntaksivalinnalla voidaan yksinkertaistaa kieltä.
Nimittäin edellä esitetty funktiotyyppi- ja kutsu tulkitaan Haskellissa seuraavasti:

\begin{minted}{haskell}
charAt :: String -> (Int -> Char)
(charAt "foo") 0
\end{minted}

Selviääkin, että Haskellin ainoa funktiotyyppi on yksiparametrinen funktio,
ja useampiparametriset funktiot on toteutettu funktioina, jotka palauttavat toisia funktioita.
Eli siis selvennettynä,
\Haskell{charAt} onkin funktio, joka ottaa \Haskell{String}:n ja palauttaa funktion,
joka ottaa \Haskell{Int}:n ja palauttaa \Haskell{Char}:n.

\subsection{Osittainsovellus}
Edellisessä luvussa esitellyillä funktioiden ominaisuuksilla on muutakin etua
kuin kielen yksinkertaistaminen; niiden avulla ohjelmia voi lyhentää tietyissä tilanteissa.
Tarkastellaan seuraavaksi \Haskell{filterPositives}-funktiota, joka poistaa listasta kaikki
epäpositiiviset luvut.
Perinteinen tapa kirjoittaa kyseinen funktio näyttää tältä:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives luvut = filter (\x -> x > 0) luvut
\end{minted}

Edellisen voi kuitenkin kirjoittaa hieman lyhyemmin käyttämällä osittain soveltamista
(engl. partial application) seuraavasti:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (\x -> x > 0)
\end{minted}

Kun kaksiparametriselle funktiolle \Haskell{filter} annetaan vain yksi kiinteä parametri,
tulee lausekkeen arvoksi yksiparametrinen funktio,
joka paluuarvonaan kutsuu \Haskell{filter}:iä sekä kiinteällä parametrillä että puuttuvalla parametrilla.

Haskellissa on myös syntaksisokeria binäärioperaattorien osittain soveltamiselle.
Mielivaltaiselle binäärioperaattorille \Haskell{@}:
\begin{itemize}
    \item \Haskell{(@ lauseke)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> x @ lauseke)}
    \item \Haskell{(lauseke @)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> lauseke @ x)}
\end{itemize}

Tämän avulla voidaan \Haskell{filterPositives}-esimerkkiä lyhentää vielä lisää:
\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (>0)
\end{minted}
\fi

\subsection{Laiskuus}

Haskell on \emph{laiskasti evaluoitu} ohjelmointikieli,
joka tarkoittaa,
että Haskellissa lausekkeen arvoa ei evaluoida,
ennen kuin sitä tarvitaan.
Seuraava ohjelmaesimerkki havainnollistaa asiaa:

\begin{listing}[H]
    \inputminted{haskell}{codes/Laziness.hs}
    \label{lst:laziness}
    \caption{\texttt{Laziness.hs:} Esimerkki laiskasta evaluaatiosta}
\end{listing}

Listauksessa \ref{lst:laziness} \Haskell{nums}-niminen lista on alustettu arvoilla,
jotka ei-laiskassa ohjelmointikielissä aiheuttaisivat virheen jo listan alustusrivillä:
listan ensimmäisen alkion alustuksessa jaetaan nollalla ja kolmannennen alkion
alustus päätyy ikuiseen rekursioon.
Haskell-ohjelman tulostuksista voidaan sen sijaan nähdä,
että siitä huolimatta \Haskell{nums}-listaa voidaan käsitellä varsin monella
tavoin ilman suorituksen keskeytymistä tai jumiutumista.
Myöskään muuttujan \Haskell{divByZeroPlusOne} luominen ei kaada ohjelmaa,
vaan vasta \Haskell{print}-funktion kutsuminen aiheuttaa lausekkeen
\Haskell{1 `div` 0} evaluoinnin, jolloin ohjelman suoritus päättyy
eikä viimeistä tulostusta tapahdu.

\subsection{Laiskuuden käyttötapauksia}

Monissa ohjelmointikielissä (kuten Javassa) monet loogiset operaattorit käyttävät oikomuotoevaluaatiota (short-circuit evaluation),
eli operaattorin oikeanpuolemmaista parametriä ei evaluoida tietyissä tilanteissa.
Esimerkiksi seuraavassa esimerkissä tyhjä merkkijonoparametri funktiolla \texttt{startsWithDash} ei
aiheuta \texttt{IndexOutOfBoundsException}-poikkeusta:

\begin{minted}{java}
    public static bool startsWithDash(String s) {
        return s.length() > 0 && s.charAt(0) == '-';
    }
\end{minted}

Javassa vain sisäänrakennetuilla \texttt{||}- ja \texttt{\&\&}-operaattoreilla on tämä ominaisuus,
eikä ohjelmoija voi mitenkään itse tehdä uutta operaattoria tai funktiota,
joka käyttäisi oikomuotoevaluaatiota.
Haskellissa sen sijaan laiskan evaluaation ansiosta Javan tyyliset \texttt{||}- ja \texttt{\&\&}-operaattorit on
yksinkertaisesti toteutettu seuraavina kirjastofunktioina:

\begin{minted}{haskell}
True  && x       =  x
False && _       =  False

True  || _       =  True
False || x       =  x
\end{minted}

\section{Metaohjelmointi Haskellilla}
\subsection{Template Haskell}

Template Haskell~\cite{ThPaper} on GHC-kääntäjän toteuttama epävirallinen laajennos Haskell-kieleen,
joka tarjoaa mahdollisuudet käännösaikaiseen metaohjelmointiin makrojen muodossa.

Makrojärjestelmät voidaan karkeasti jakaa tekstuaalisiin makroihin sekä syntaktisiin makroihin.
Tunnetuimpia esimerkkejä tekstuaalisista makroista on C-kielen esikääntäjä sekä erinäisten assemblereiden makrokielet,
kun taas syntaktiset makrot ovat Lisp-kieliperheen tavaramerkki.
Template Haskellin tarjoamat makrot lukeutuvat näistä kategorioista jälkimmäiseen:
Template Haskell-makrot ovat tavallisia Haskell-funktioita,
joilla on paluutyyppinä Template Haskell-kirjastossa määritelty syntaksipuutyyppi.

\subsection{Template Haskell-esimerkki}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/THExample.hs}
    \label{lst:example-definition}
    \caption{\texttt{THExample.hs:} Esimerkki Template Haskell-makrosta}
\end{listing}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/Main.hs}
    \label{lst:example-usage}
    \caption{\texttt{Main.hs:} Esimerkki edeltävän makron käytöstä}
\end{listing}

Listauksessa \ref{lst:example-definition} määritellään makro \Haskell{compileTimeEval},
jonka avulla voidaan tehdä laskutoimituksia käännösaikana.
Huomattavaa on, että koko kyseinen moduuli on aivan standardia Haskell 2010-koodia
ja että \Haskell{compileTimeEval} on vain tavallinen Haskell-funktio,
jonka paluutyyppinä sattuu olemaan \Haskell{Q Exp}.

Listauksessa \ref{lst:example-usage} esitellään \Haskell{compileTimeEval}-makron käyttöä,
mää\-rit\-tele\-mäl\-lä nimet \Haskell{foo} ja \Haskell{bar} sen avulla.
Makron käyttö tapahtuu dollarimerkkisyntaksilla \Haskell{\$(\emph{lauseke})},
jossa \emph{lauseke} voi olla mielivaltaista Haskell-koodia.
Koska dollarisyntaksi ja Template Haskell itsessään ei kuulu Haskell 2010-standardiin,
on moduulin alkuun täytynyt laittaa pragma \Haskell{LANGUAGE TemplateHaskell}
Template Haskell-laajennoksen sallimiseksi.

Kääntäessä \Haskell{Main.hs}-moduulia voidaan havaita,
että \Haskell{\$(compileTimeEval ...)}-lausekkeiden arvot todella lasketaan käännösaikana:
ensin useita sekunteja kuluu lukujen 1--10 000 000 summan laskemiseen,
sitten käännös päättyy virheeseen,
koska makroekspansion aikana jaettiin nollalla.
Siis \Haskell{\$()}-rakenteen sisällä oleva lauseke suoritetaan käännösaikana,
ja sen paluuarvona oleva syntaksipuu (tyyppiä \Haskell{Q Exp}) liitetään käännettävän moduulin
syntaksipuuhun.

Template Haskellin moduuli \Haskell{Language.Haskell.TH.Syntax} tarjoaa tyypin \Haskell{Exp},
joka vastaa Haskellin lausekkeen syntaksipuun tyyppiä.
Moduulista \Haskell{Language.Haskell.TH.Lib} löytyvät apufunktiot \Haskell{litE :: Lit -> Q Exp}
sekä \Haskell{litE :: Integer -> Lit},
joiden avulla luodaan kokonaislukuliteraalia vastaava syntaksipuun lehtisolmu.
Tyypin \Haskell{Q Exp} edessä esiintyvä \Haskell{Q} viittaa Template Haskellin
\emph{siteerausmonadiin} (quotation monad),
jonka tarkemmat yksityiskohdat jätetään yksinkertaistuksen takia tässä huomiotta.
Mainittavaa kuitenkin on,
että \Haskell{Q}:n avulla voidaan makroekspansion aikana muun muassa päästä käsiksi kääntäjän symbolitauluun,
jonka avulla voidaan esimerkiksi tarkastella mitä funktioita ja tyyppejä makron kutsukohdan näkyvyysalueelta
löytyy. Näitä Template Haskellin tarjoamia keinoja ei tässä työssä kuitenkaan tutkita.

\subsection{Syntaksipuu}
Koska Template Haskell-makrojen pääasiallinen tavoite on tuottaa koodia syntaksipuun muodossa,
on syntaksipuuta vastaavat Haskell-tietorakenteet erittäin keskeisessä osassa.
Kyseiset tietotyypit löytyvät kirjastomoduulista \Haskell{Language.Haskell.TH.Syntax}.
Listauksessa \ref{lst:syntax-tree-types} on annettu joidenkin tärkeiden tietotyyppien
osittaiset määritelmät:
\begin{itemize}
    \item Tyyppi \Haskell{Exp} vastaa lausekkeen syntaksipuuta.
    \item Tyyppi \Haskell{Pat} vastaa hahmonsovituksessa käytettävien hahmojen syntaksipuuta.
    \item Tyyppi \Haskell{Lit} vastaa kielen vakioiden (literal) syntaksipuun tyyppiä
\end{itemize}

\begin{listing}[H]
\begin{minted}{haskell}
data Lit = CharL Char
         | StringL String
         | IntegerL Integer
         | RationalL Rational

data Pat
  = LitP Lit            -- vakion hahmo: 'a', 42 jne.
  | VarP Name           -- muuttujan hahmo: esim. x
  | TupP [Pat]          -- monikon hahmo: esim. (p1, p2)
  | ConP Name [Pat]     -- tyyppikonstruktorin hahmo: Ctor p1 p2
  | WildP               -- wildcard-hahmo: _

data Exp
  = VarE Name           -- muuttujannimi: esim. foo
  | ConE Name           -- tyyppikonstruktori: esim. True
  | LitE Lit            -- vakio: esim. 'a', 42 tai "mjono"
  | AppE Exp Exp        -- funktiokutsu: esim. f x

  | ParensE Exp         -- lauseke suluissa: esim. (e)
  | LamE [Pat] Exp      -- anonyymi funktio: \ p1 p2 -> e
  | TupE [Exp]          -- monikon muodostus: esim. (e1, e2)
  | CondE Exp Exp Exp   -- ehtolauseke: if e1 then e2 else e3
  | LetE [Dec] Exp      -- muuttujien maaritys: let x=e1; y=e2... in e3
  | CaseE Exp [Match]   -- case-lauseke: case e of m1; m2
\end{minted}
\label{lst:syntax-tree-types}
\caption{Joitakin Template Haskellin keskeisiä syntaksipuutietotyyppejä.}
\end{listing}

Merkillepantavaa on,
että Haskellin algebralliset tietotyypit sopivat erinomaisesti syntaksipuutyypin esittämiseen!
Esimerkiksi Javassa lausekkeen tietotyypin määrittely vastaavasti vaatisi ensin abstraktin yliluokan
\Haskell{abstract class Exp} sekä kasan aliluokkia \Haskell{class VarE extends Exp},
\Haskell{class ConE extends Exp} jne.
Erityisesti tässä tilanteessa Haskell-koodi onnistuu olemaan huomattavasti tiiviimpää kuin vastaava Java-koodi.

\subsection{\Haskell{zip$N$}-funktioiden generointi Template Haskellilla}

Eräs Haskellissa yleisesti listojen käsittelyyn käytetty funktio on \Haskell{zip},
tyypiltään \Haskell{zip :: [a] -> [b] -> [(a, b)]},
joka ottaa parametrinä kaksi listaa,
ja muodostaa niistä listan pareja.

\begin{listing}[H]
\begin{minted}{haskell}
zip "abc" "xyz"
-- => [('a', 'x'), ('b', 'y'), ('c', 'z')]

zip ["yksi", "kaksi", "kolme"] [1..10]
-- => [("yksi", 1), ("kaksi", 2), ("kolme", 3)]
-- eripituisilla listoilla ylijaavat alkiot pudotetaan pois
\end{minted}
\label{lst:zip-example}
\caption{Esimerkki \Haskell{zip}-funktion käytöstä}
\end{listing}

\Haskell{zip}-funktion voi yleistää myös mielivaltaiselle määrälle listoja;
esimerkiksi standardikirjaston funktio \Haskell{zip3} ottaa kolme listaa ja tuottaa listan kolmikoita.

\begin{minted}{haskell}
zip  :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
-- jne.
\end{minted}

Funktiot \Haskell{zip} ja \Haskell{zip3} voisi toteuttaa esimerkiksi seuraavasti:

\begin{listing}[H]
\begin{minted}{haskell}
zip l1 l2 = if or [null l1, null l2]
    then []
    else (head l1, head l2) : zip (tail l1) (tail l2)

zip3 l1 l2 l3 = if or [null l1, null l2, null l3]
    then []
    else (head l1, head l2, head l3) : zip3 (tail l1) (tail l2) (tail l3)
\end{minted}
\label{lst:zip-impl}
\caption{Esimerkkitoteutukset \Haskell{zip}- ja \Haskell{zip3}-funktioille.}
\end{listing}

\Haskell{or}-funktio \Haskell{or :: [Bool] -> Bool} tekee loogisen TAI-operaation parametrilistan
jokaiselle alkiolle,
tai toisin sanottuna tarkastaa, onko jokin listan alkio \Haskell{True}.
Siis jos mikä tahansa parametrilistoista on tyhjä, niin \Haskell{zip$N$}-funktion paluuarvo on tyhjä lista,
muulloin luodaan monikko jokaisen parametrilistan ensimmäisestä alkiosta,
ja liitetään se rekursiivisesti tehtyyn \Haskell{zip$N$}-kutsuun loppulistoille.

Ohjelmoijan kannalta olisi ikävää, jos jokainen \Haskell{zip}-variantti pitäisi toteuttaa käsin.
Template Haskellia käyttämällä on kuitenkin mahdollista luoda makro,
jolla \Haskell{zip}-funktioiden luomisen voi automatisoida.

\begin{listing}[H]
    \inputminted{haskell}{codes/zip-generator/MakeZip.hs}
    \label{lst:make-zip}
    \caption{Mielivaltaisen \Haskell{zip$N$}-funktion generoiva Template Haskell-makro.}
\end{listing}

Listauksessa \ref{lst:make-zip} määritellään makro \Haskell{makeZip},
joka generoi koodin mielivaltaiselle \Haskell{zip}-funktiolle listauksessa \ref{lst:zip-impl}
esitettyjen toteutuksen tyyliin.
Funktio \Haskell{makeZip} on tyyppiä \Haskell{makeZip :: Int -> Q Dec}.
Paluutyyppi on tässä tapauksessa eri kuin aiemmin nähty \Haskell{Q Exp},
koska makron lopputuloksena ei ole lauseke,
vaan kokonainen funktion määrittely.

Itse makron toteutus koostuu kasasta apumäärittelyjä, joista tärkeimmät ovat:
\begin{itemize}
    \item \Haskell{functionName} on määriteltävän funktion nimi, tyyppiä \Haskell{Name}.
          Template Haskellissa nimille on oma tietotyyppi \Haskell{Name},
          joita voi luoda kirjastofunktiolla \Haskell{mkName :: String -> Name}.
          Huomattavaa on erikoistapaus kun ariteetti on 2 -- tällöin funktion nimi on \Haskell{zip},
          eikä \Haskell{zip2}.

    \item \Haskell{argNames} on lista määriteltävän funktion parametrien nimistä, tyyppiä \Haskell{[Name]}.
          Esimerkiksi \Haskell{zip3}:n tapauksessa parametrien nimet ovat \Haskell{l1}, \Haskell{l2} ja \Haskell{l3}.

    \item \Haskell{body} on funktion runko: syntaksipuuliteraalin avulla muodostettu \Haskell{if}-lauseke,
          johon on liitetty (splice) \Haskell{\$()}-notaation avulla seuraavan kolmen apumäärittelyn syntaksipuut.

    \item \Haskell{isEmptyExprs} on rungon ehtolausekkeen ehdossa käytetty lausekkeen syntaksipuu,
          joka vastaa \Haskell{zip3}:n tapauksessa listauksen \ref{lst:zip-impl} lauseketta \Haskell{[null l1, null l2, null l3]}.
          Jokainen yksittäinen listan alkio (esimerkiksi \Haskell{null l1}) on luotu syntaksipuuliteraalia
          ja spliceä käyttäen.
          Kirjastofunktiolla \Haskell{varE :: Name -> Q Exp} muodostaa syntaksipuun lausekkeelle, joka
          viittaa johonkin nimettyyn muuttujaan.
          Kirjastofunktio \Haskell{listE :: [Q Exp] -> Q Exp} muodostaa syntaksipuun listaliteraalille.

    \item \Haskell{tupleExpr} on paluuarvolistaan lisätyn monikon lausekkeen syntaksipuu,
          joka vastaa \Haskell{zip3}:n tapauksessa listauksen \ref{lst:zip-impl} kohtaa \\ \Haskell{(head l1, head l2, head l3)}.
          Kirjastofunktio \Haskell{tupE ::} \\ \Haskell{[Q Exp] -> Q Exp} muodostaa syntaksipuun monikkoliteraalille.

    \item \Haskell{recursiveCallExpr} on rekursiivisen \Haskell{zip}-kutsun syntaksipuu,
          joka vastaa \Haskell{zip3}:n tapauksessa listauksen \ref{lst:zip-impl} kohtaa \\ \Haskell{zip3 (tail l1) (tail l2) (tail l3)}.
          Kirjastofunktio \Haskell{appsE ::} \\ \Haskell{[Q Exp] -> Exp} muodostaa syntaksipuun funktiokutsulle.
          \Haskell{appsE}:lle parametrina annetun listan ensimmäinen alkio on lausekkeen syntaksipuu kutsuttavalle funktiolle,
          ja listan loput alkiot ovat syntaksipuita funktiokutsun parametreille.
\end{itemize}

Lopuksi apumäärittely \Haskell{clauses} ja paluuarvo \Haskell{runQ (funD functionName clauses)} sitoo yhteen
funktion nimen, parametrilistan sekä funktion rungon.
Nyt \Haskell{makeZip}-makroa voi käyttää esimerkiksi seuraavasti:
\begin{minted}{haskell}
{-# LANGUAGE TemplateHaskell #-}
import MakeZip(makeZip)

$(mapM makeZip [4..20])
main = print (zip6 [1] ['a'] ["b"] [4] [5] [6, 7])
\end{minted}
Rivillä \Haskell{\$(mapM makeZip [2..20])} suoritetaan \Haskell{makeZip}-makro arvoilla 2--20,
ja seuraavalla rivillä kutsutaan testiksi \Haskell{zip6}-funktiota.
Ohjelma tulostaa:
\begin{minted}{haskell}
[(1,'a',"b",4,5,6)]
\end{minted}

\section{Yhteenveto}
