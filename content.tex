\section{Johdanto}
\section{Haskell}
\subsection{Yleistä}
Haskell on staattisesti- ja vahvasti tyypitetty laiska, puhtaasti funktionaalinen ohjelmointikieli.

Haskell-kielen suunnittelu ja kehitys alkoi vuonna 1987,
jolloin päämääränä oli tuoda lukuisten, hyvin samankaltaisten laiskojen puhtaasti funktionaalisten tutkimuskielien ideat yhteen.
Tällä hetkellä kielen uusin spesifikaatio ``Haskell Language Report'' on vuodelta 2010.~\cite{HaskellReport2010}.

Aktiivisesti kehitettyjä sekä ajantasaisia Haskell-kääntäjiä on käytännössä ainoastaan
GHC, Glasgow Haskell Compiler~\cite{GHC}.
Itse kielen käyttäjiä varten julkaistaan säännöllisesti Linux-, Windows- ja
Mac OS X-käyttöjärjestelmille  jakelupaketti ``Haskell Platform''~\cite{HaskellPlatform},
joka sisältää GHC:n lisäksi kirjastoja esimerkiksi yksikkötestaukseen, POSIX-rajapintoihin
sekä OpenGL:ään.

Haskellin syntaksi poikkeaa suhteellisen paljon muista yleisesti käytetyistä ohjelmointikielistä.
Listauksessa \ref{lst:first-example} on esimerkki,
joka kysyy käyttäjältä nimeä ja tervehtii käyttäjää.

\begin{listing}[H]
    \inputminted{haskell}{codes/FirstExample.hs}
    \label{lst:first-example}
    \caption{Yksinkertainen Haskell-esimerkki.}
\end{listing}

Esimerkistä selviää muun muassa, että lohkorakenteita ei ole ilmaistu muulla kuin sisennyksellä,
eikä lausekkeiden loppuun tarvitse laittaa päätemerkkiä (kuten puolipistettä).
Välilyönnit ja rivinvaihdot ovat siis Haskellissa merkityksellisiä.
Myöskin erikoista muihin staattisesti tyypitettyihin ohjelmointikieliin verrattaessa on,
ettei koko ohjelmassa ole yhtään tyyppimäärittelyä.
Haskellin tyyppijärjestelmä perustuu nk. Hindley-Milner-tyyppijärjestelmään~\cite{Hindley,Milner},
joka mahdollistaa sekä muuttujien että funktioiden automaattisen tyyppienpäättelyn useimmissa tapauksissa.
Funktiokutsun syntaksi eroaa myös yleisesti käytetystä notaatiosta;
Haskellissa funktiokutsussa ei käytetä sulkeita (paitsi lausekkeiden ryhmittelyyn) ja parametrit erotetaan vain välilyönneillä.
Taulukossa \ref{tbl:function-call-examples} on joitakin selventäviä esimerkkejä syntaksien eroista.

\begin{table}
    \begin{tabular}[H]{c|c}
        Java                    &   Haskell         \\
        \hline
        \texttt{f()}            &   \texttt{f}              \\
        \texttt{f(x, y, z)}     &   \texttt{f x y z}        \\
        \texttt{f(x(a), y(t))}  &   \texttt{f (x a) (y t)}  \\
    \end{tabular}
    \label{tbl:function-call-examples}
    \caption{Esimerkkejä Javan ja Haskellin funktiokutsusyntaksin eroista.}
\end{table}

\subsection{Perustyyppejä ja kontrollirakenteita}
Haskellista löytyy kaksi kokonaislukutyyppiä: \Haskell{Int},
jonka lukualue on rajallinen (toteutuksesta riippuen, kuitenkin vähintään 30 bittiä)
sekä \Haskell{Integer},
jonka lukualue on rajaton.
Liukulukutyyppeinä löytyy \Haskell{Float} ja \Haskell{Double},
jotka vastaavat lähes kaikkien muidenkin ohjelmointikielten käyttämiä IEEE 754-standardin mukaisia liukulukuja.
Kaikille lukuliteraaleille syntaksi on samanlainen kuin Javassa.
Totuusarvojen tyyppi on \Haskell{Bool},
mutta yleisestä käytännöstä poiketen itse totuusarvot ovat \Haskell{True} ja \Haskell{False} isoilla alkukirjaimilla.
Tälle erolle kirjainkoossa on itse syy; Haskellissa nimen ensimmäisen alkukirjaimen kirjainkoolla on merkitystä
ja sekä tyyppien että vakioiden nimien täytyy alkaa isolla alkukirjaimella.

Useista imperatiivisista kielistä poiketen \Haskell{if-then-else}-konstruktio ei ole lause (statement),
vaan lauseke (expression).
Siis \Haskell{if} palauttaa aina arvon, mikä tarkoittaa myös että \Haskell{else}-haara on aina pakollinen.

\begin{minted}{haskell}
henkilonKuvaus ika = if ika < 18
                        then "Lapsi"
                        else "Aikuinen"
luvunKuvaus n = "Luku on " ++ (if n < 0 then "negatiivinen" else "positiivinen")
\end{minted}

Useamman kuin yhden ehdon vertailulle on oma syntaksinsa.

\begin{minted}{haskell}
fizzbuzz n | n % 15 == 0 = "FizzBuzz"
           | n % 3  == 0 = "Fizz"
           | n % 5  == 0 = "Buzz"
           | otherwise   = show n
\end{minted}

Koska Haskell on puhtaasti funktionaalinen ohjelmointikieli,
ei muuttujan arvon muuttaminen ole mahdollista.
Näinollen kielessä ei myöskään ole ollenkaan silmukoita kontrollirakenteina,
vaan niiden tilalla on käytettävä rekursiota.
Esimerkiksi kertomafunktio voitaisiin toteuttaa seuraavasti:

\begin{minted}{haskell}
factorial n | n == 0    = 1
            | otherwise = n * factorial (n - 1)
\end{minted}

Kun käytetään rekursiota silmukan korvikkeena,
on oltava tarkkana rekursiokutsujen viemän pinokehyksien tilamäärän kanssa.
Esimerkiksi edellisen esimerkin \Haskell{factorial}-funktio on epätehoton ja käyttää lineaarisen määrän muistia.
Monet rekursiiviset funktiot on kuitenkin apufunktion avulla mahdollista kirjoittaa siten,
että ne käyttävät vakiomäärän muistia.
Koska tällaisia apufunktion vaativia tilanteita tulee Haskellissa vastaan usein,
voi \Haskell{where}-avainsanalla tehdä paikallisia muuttujien- ja funktioiden määrittelyjä.

\begin{minted}{haskell}
factorial n = fac' n 1
    where fac' n acc | n == 0    = acc
                     | otherwise = fac' (n - 1) (n * acc)
\end{minted}

Edellisessä esimerkissä funktion \Haskell{fac'} näkyvyys on ainoastaan \Haskell{factorial}-funktion sisällä.

\subsection{Hahmonsovitus}
Hahmonsovituksen (pattern matching) voidaan katsoa olevan laajennettu versio esim. javan \texttt{switch}-lauseesta.
Eräs tapa käyttää hahmonsovitusta Haskellissa on \Haskell{case}-lauseke:
\begin{minted}{haskell}
fibonacci n = case n of
                1 -> 1
                2 -> 1
                _ -> fibonacci (n - 1) + fibonacci (n - 2)
\end{minted}
Edellisessä esimerkissä parametriä \Haskell{n} verrataan järjestyksessa hahmoihin \Haskell{1}, \Haskell{2} ja \Haskell{\_},
ja suoritus jatkuu siltä riviltä jolla vertailu onnistui.
Hahmo \Haskell{\_} on ``wildcard'' eli arvon vertailu hahmoon onnistuu aina.

Koska hahmonsovitusta käytetään Haskellissa paljon, on sille lyhyempi syntaksi olemassa:
hahmonsovitusta voi tehdä suoraan funktion parametrilistassa:

\begin{minted}{haskell}
fibonacci 1 = 1
fibonacci 2 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
\end{minted}

\subsection{Listat}

Kuten muissakin funktionaalisen paradigman ohjelmointikielissä,
Haskellissa perustietorakenne tiedon säilömiseen on linkitetty lista eikä taulukko.
Listan tyyppi kirjoitetaan hakasulkeilla, esimerkiksi tyyppi \Haskell{[Integer]} on lista kokonaislukuja.
Haskellissa ei ole erikseen tietotyyppiä merkkijonoille,
vaan \Haskell{String} on alias tyypille \Haskell{[Char]},
jossa \Haskell{Char}-tyyppi vastaa Unicode-merkkiä.

Listaliteraalin voi luoda laittamalla alkiot hakasulkujen sisään pilkulla erotettuina.
Merkkijonoliteraali on vain erikoissyntaksi \Haskell{Char}-listalle.
\begin{minted}{haskell}
luvut = [1, 2, 3]
mjono1 = "foo"           -- tyyppi [Char]
mjono2 = ['f', 'o', 'o'] -- tyyppi [Char], sama kuin mjono1
\end{minted}

Linkitetyn listan toteutus esimerkiksi Javassa on tyypillisesti solmuluokka,
joka sisältää yhtenä kenttänä listan alkion ja toisena kenttänä viitteen seuraavaan solmuun.
Haskellissa listasolmua vastaa nk. cons-operaattori \Haskell{:}, joka voidaan
mieltää operaattorina joka lisää olemassaolevan listan alkuun yhden alkion.
Esimerkiksi \Haskell{[1, 2, 3]} cons-operaattorin avulla ilmaistuna on \Haskell{1:2:3:[]},
tai täysin sulutettuna \Haskell{1:(2:(3:[]))}.
\Haskell{:}-operaattori on myös samalla \emph{tyyppikonstruktori},
mikä tarkoittaa että sitä voidaan käyttää hahmonsovituksessa.

\begin{minted}{haskell}
length []     = 0
length (_:xs) = 1 + length xs

containsElement []     elem = False
containsElement (x:xs) elem | x == elem = True
                            | otherwise = containsElement xs elem
\end{minted}

\subsection{Operaattorit}
Haskellissa kaikkia nimettyjä funktioita voi vaihtoehtoisesti käyttää binäärioperaattorina ympäröimällä funktion nimi kenohipsuilla (\texttt{`}):
\begin{minted}{haskell}
divides m n = n `mod` m == 0
\end{minted}

Toisin kuin monissa muissa operaattoreille infiksisyntaksia käyttävissä ohjelmointikielissä,
Haskellissa käytettävissä olevia operaattoreita ei ole erikseen kovakoodattu kieleen,
vaan ohjelmoija voi itse määritellä mielivaltaisia operaattoreita.

\begin{listing}[H]
\begin{minted}{haskell}
(x1, y1) <+> (x2, y2) = (x1 + x2, y1 + y2)
(x, y) .* k = (k * x, k * y)
infixl 6 <+>
infixl 7 .*
\end{minted}
\label{lst:operators-example}
\caption{Esimerkki omien operaattoreiden määrittelystä.}
\end{listing}

Listauksessa \ref{lst:operators-example} määritellään kaksiuloitteisen vektorin yhteenlaskua
ja skalaarilla kertomista vastaavat operaattorit \Haskell{<+>} ja \Haskell{.*}.
Myös operaattoreiden sidontajärjestys on ohjelmoijan valittavissa;
avainsanoilla \Haskell{infixl}, \Haskell{infixr} ja \Haskell{infix} määritellään sekä
operaattoreiden suhteellinen prioriteetti (kokonaislukuna 0--9, pienempi sitoo tiukemmin) että
samanprioriteettisten operaattoreiden laskemissuunta
(vasemmalta oikealle, oikealta vasemmalle tai ei sallittu).
Siis listauksen \ref{lst:operators-example} operaattoreita käyttäen olisi lauseke
\Haskell{(1, 2) <+> 3 .* (4, 5)} tulkittavissa perinteisten matemaattisten operaattorien tapaan,
eli \Haskell{(1, 2) <+> (3 .* (4, 5))}.

\subsection{Funktioiden lähempää tarkastelua}
Kuten aiemmissa luvuissa on nähty,
Haskellin funktiotyypin ja funktiokutsun syntaksi poikkeaa paljon muista ohjelmointikielistä.
Esimerkiksi Javassa hypoteettisen \texttt{charAt}-funktion tyypin syntaksi on

\begin{itemize}
    \item funktion tyyppi: \texttt{char charAt(String str, int index)}
    \item funktiokutsu: \texttt{charAt("foo", 0)}
\end{itemize}
Haskellissa taasen:
\begin{itemize}
    \item funktion tyyppi: \Haskell{charAt :: String -> Int -> Char}
    \item funktiokutsu: \Haskell{charAt "foo"\, 0}
\end{itemize}

Isoimpana erona Javaan verrattuna on, että Haskellissa funktion paluuarvo tulee loppuun eikä alkuun,
ja funktiokutsussa sulkeita ei tarvita.
Tämä ero ei ole tehty muiden ohjelmointikielten käyttäjien hämäämiseksi,
vaan tällä syntaksivalinnalla voidaan yksinkertaistaa kieltä.
Nimittäin edellä esitetty funktiotyyppi- ja kutsu tulkitaan Haskellissa seuraavasti:

\begin{minted}{haskell}
charAt :: String -> (Int -> Char)
(charAt "foo") 0
\end{minted}

Selviääkin, että Haskellin ainoa funktiotyyppi on yksiparametrinen funktio,
ja useampiparametriset funktiot on toteutettu funktioina, jotka palauttavat toisia funktioita.
Eli siis selvennettynä,
\Haskell{charAt} onkin funktio, joka ottaa \Haskell{String}:n ja palauttaa funktion,
joka ottaa \Haskell{Int}:n ja palauttaa \Haskell{Char}:n.

\subsection{Osittainsovellus}
Edellisessä luvussa esitellyillä funktioiden ominaisuuksilla on muutakin etua
kuin kielen yksinkertaistaminen; niiden avulla ohjelmia voi lyhentää tietyissä tilanteissa.
Tarkastellaan seuraavaksi \Haskell{filterPositives}-funktiota, joka poistaa listasta kaikki
epäpositiiviset luvut.
Perinteinen tapa kirjoittaa kyseinen funktio näyttää tältä:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives luvut = filter (\x -> x > 0) luvut
\end{minted}

Edellisen voi kuitenkin kirjoittaa hieman lyhyemmin käyttämällä osittain soveltamista
(engl. partial application) seuraavasti:

\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (\x -> x > 0)
\end{minted}

Kun kaksiparametriselle funktiolle \Haskell{filter} annetaan vain yksi kiinteä parametri,
tulee lausekkeen arvoksi yksiparametrinen funktio,
joka paluuarvonaan kutsuu \Haskell{filter}:iä sekä kiinteällä parametrillä että puuttuvalla parametrilla.

Haskellissa on myös syntaksisokeria binäärioperaattorien osittain soveltamiselle.
Mielivaltaiselle binäärioperaattorille \Haskell{@}:
\begin{itemize}
    \item \Haskell{(@ lauseke)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> x @ lauseke)}
    \item \Haskell{(lauseke @)} on sama kuin lambda-lauseke \Haskell{(\textbackslash x -> lauseke @ x)}
\end{itemize}

Tämän avulla voidaan \Haskell{filterPositives}-esimerkkiä lyhentää vielä lisää:
\begin{minted}{haskell}
filterPositives :: [Int] -> [Int]
filterPositives = filter (>0)
\end{minted}

\subsection{Laiskuus}

Haskell on \emph{laiskasti evaluoitu} ohjelmointikieli,
joka tarkoittaa että Haskellissa lausekkeen arvoa ei evaluoida ennen kuin sitä tarvitaan.
Seuraava ohjelmaesimerkki havainnollistaa asiaa:

\begin{listing}[H]
    \inputminted{haskell}{codes/Laziness.hs}
    \label{lst:laziness}
    \caption{\texttt{Laziness.hs:} Esimerkki laiskasta evaluaatiosta}
\end{listing}

Listauksessa \ref{lst:laziness} \Haskell{nums}-niminen lista on alustettu arvoilla,
jotka ei-laiskassa ohjelmointikielissä aiheuttaisivat virheen jo listan alustusrivillä:
listan ensimmäisen alkion alustuksessa jaetaan nollalla ja kolmannennen alkion
alustus päätyy ikuiseen rekursioon.
Haskell-ohjelman tulostuksista voidaan sen sijaan nähdä,
että siitä huolimatta \Haskell{nums}-listaa voidaan käsitellä varsin monella
tavoin ilman suorituksen keskeytymistä tai jumiutumista.
Myöskään muuttujan \Haskell{divByZeroPlusOne} luominen ei kaada ohjelmaa,
vaan vasta \Haskell{print}-funktion kutsuminen aiheuttaa lausekkeen
\Haskell{1 `div` 0} evaluoinnin, jolloin ohjelman suoritus päättyy
eikä viimeistä tulostusta tapahdu.

\subsection{Laiskuuden käyttötapauksia}

Monissa ohjelmointikielissä (kuten Javassa) monet loogiset operaattorit käyttävät nk. short-circuit-evaluaatiota,
eli operaattorin oikeanpuolemmaista parametriä ei evaluoida tietyissä tilanteissa.
Esimerkiksi seuraavassa esimerkissä tyhjä merkkijonoparametri funktiolla \texttt{startsWithDash} ei
aiheuta \texttt{IndexOutOfBoundsException}-poikkeusta:

\begin{minted}{java}
    public static bool startsWithDash(String s) {
        return s.length() > 0 && s.charAt(0) == '-';
    }
\end{minted}

Javassa vain sisäänrakennetuilla \texttt{||}- ja \texttt{\&\&}-operaattoreilla on tämä ominaisuus,
eikä ohjelmoija voi mitenkään itse tehdä uutta operaattoria tai funktiota,
joka käyttäisi short-circuit-evaluaatiota.
Haskellissa sen sijaan laiskan evaluaation ansiosta Javan tyyliset \texttt{||}- ja \texttt{\&\&}-operaattorit on
yksinkertaisesti toteutettu seuraavina kirjastofunktioina:

\begin{minted}{haskell}
True  && x       =  x
False && _       =  False

True  || _       =  True
False || x       =  x
\end{minted}

\section{Metaohjelmointi Haskellilla}
\subsection{Template Haskell}

Template Haskell~\cite{ThPaper} on GHC-kääntäjän toteuttama epävirallinen laajennos Haskell-kieleen,
joka tarjoaa mahdollisuudet käännösaikaiseen metaohjelmointiin makrojen muodossa.

Makrojärjestelmät voidaan karkeasti jakaa tekstuaalisiin makroihin sekä syntaktisiin makroihin.
Tunnetuimpia esimerkkejä tekstuaalisista makroista on C-kielen esikääntäjä sekä erinäisten assemblereiden makrokielet,
kun taas syntaktiset makrot ovat Lisp-kieliperheen tavaramerkki.
Template Haskellin tarjoamat makrot lukeutuvat näistä kategorioista jälkimmäiseen:
Template Haskell-makrot ovat tavallisia Haskell-funktioita,
joilla on paluutyyppinä Template Haskell-kirjastossa määritelty syntaksipuutyyppi.

\subsection{Template Haskell-esimerkki}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/THExample.hs}
    \label{lst:example-definition}
    \caption{\texttt{THExample.hs:} Esimerkki Template Haskell-makrosta}
\end{listing}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/Main.hs}
    \label{lst:example-usage}
    \caption{\texttt{Main.hs:} Esimerkki edeltävän makron käytöstä}
\end{listing}

Listauksessa \ref{lst:example-definition} määritellään makro \Haskell{compileTimeEval},
jonka avulla voidaan tehdä laskutoimituksia käännösaikana.
Huomattavaa on, että koko kyseinen moduuli on aivan standardia Haskell 2010-koodia,
ja että \Haskell{compileTimeEval} on vain tavallinen Haskell-funktio,
jonka paluutyyppinä sattuu olemaan \Haskell{Q Exp}.

Listauksessa \ref{lst:example-usage} esitellään \Haskell{compileTimeEval}-makron käyttöä,
määrittelemällä nimet \Haskell{foo} ja \Haskell{bar} sen avulla.
Makron käyttö tapahtuu dollarimerkkisyntaksilla \Haskell{\$(\emph{lauseke})},
jossa \emph{lauseke} voi olla mielivaltaista Haskell-koodia.
Koska dollarisyntaksi ja Template Haskell itsessään ei kuulu Haskell 2010-standardiin,
on moduulin alkuun täytynyt laittaa pragma \Haskell{\{-\# LANGUAGE TemplateHaskell \#-\}}
Template Haskell-laajennoksen sallimiseksi.

Kääntäessä \Haskell{Main.hs}-moduulia voidaan havaita,
että \Haskell{\$(compileTimeEval ...)}-lausekkeiden arvot todella lasketaan käännösaikana:
ensin useita sekunteja kuluu lukujen 1--10 000 000 summan laskemiseen,
sitten käännös päättyy virheeseen,
koska makroekspansion aikana jaettiin nollalla.
Siis \Haskell{\$()}-rakenteen sisällä oleva lauseke suoritetaan käännösaikana,
ja sen paluuarvona oleva syntaksipuu (tyyppiä \Haskell{Q Exp}) liitetään käännettävän moduulin
syntaksipuuhun.
Template Haskellin moduuli \Haskell{Language.Haskell.TH.Syntax} tarjoaa tyypit \Haskell{Exp},
joka vastaa Haskellin lausekkeen syntaksipuun tyyppiä,
sekä tyypin \Haskell{Q},
joka on \Haskell{IO}-tyyppiin verrattavissa oleva monadityyppi.
Moduulista \Haskell{Language.Haskell.TH.Lib} löytyvät apufunktiot \Haskell{litE :: Lit -> Q Exp}
sekä \Haskell{litE :: Integer -> Lit},
joiden avulla luodaan kokonaislukuliteraalia vastaava syntaksipuun lehtisolmu.

\subsection{Syntaksipuu}
Koska Template Haskell-makrojen pääasiallinen tavoite on tuottaa koodia syntaksipuun muodossa,
on syntaksipuuta vastaavat Haskell-tietorakenteet erittäin keskeisessä osassa.
Kyseiset tietotyypit löytyvät kirjastomoduulista \Haskell{Language.Haskell.TH.Syntax}.

Tyyppi \Haskell{Exp} vastaa Haskell-lausekkeen syntaksipuuta.

\begin{minted}{haskell}
data Exp
  = VarE Name                          -- viittaus arvon nimeen, esim. foo
  | ConE Name                          -- viittaus tyyppikonstruktorin nimeen, esim. True
  | LitE Lit                           -- vakio, esim. 'a', 42 tai "mjono"
  | AppE Exp Exp                       -- funktiokutsu, esim. f x

  | InfixE (Maybe Exp) Exp (Maybe Exp) -- operaattorin kutsu tai osittainsovellus, esim:
                                       -- a + b, (+b), (a+)

  | UInfixE Exp Exp Exp                -- ???

  | ParensE Exp                        -- lauseke suluissa, esim. (x)
  | LamE [Pat] Exp                     -- lambdafunktio, \ p1 p2 -> e
  | LamCaseE [Match]                   -- case m1; m2
  | TupE [Exp]                         -- monikon muodostus, esim. (e1, e2)
  | CondE Exp Exp Exp                  -- ehtolauseke, if e1 then e2 else e3
  | LetE [Dec] Exp                     -- sitomislauseke let x=e1; y=e2 in e3
  | CaseE Exp [Match]                  -- case-lauseke: case e of m1; m2
  | DoE [Stmt]                         -- do-lauseke: do { p <- e1; e2 }
  | CompE [Stmt]                       -- ei kasitella!!! @{ [ (x,y) | x <- xs, y <- ys ] }@

  | ArithSeqE Range                    -- ei kasitella!!! @{ [ 1 ,2 .. 10 ] }@
  | ListE [Exp]                        -- lista [e1, e2, e3]
  | SigE Exp Type                      -- ei kasitella!!! @{ e :: t }@
  | RecConE Name [FieldExp]            -- ei kasitella!!! @{ T { x = y, z = w } }@
  | RecUpdE Exp [FieldExp]             -- ei kasitella!!! @{ (f x) { z = w } }@
  deriving( Show, Eq, Data, Typeable )
\end{minted}

\subsection{\Haskell{zip$N$}-funktioiden generointi Template Haskellilla}

Eräs Haskellissa yleisesti listojen käsittelyyn käytetty funktio \Haskell{zip :: [a] -> [b] -> [(a, b)]},
joka ottaa parametrinä kaksi listaa,
ja muodostaa niistä listan pareja.

\begin{listing}[H]
\begin{minted}{haskell}
zip "abc" "xyz"
-- => [('a', 'x'), ('b', 'y'), ('c', 'z')]

zip ["yksi", "kaksi", "kolme"] [1..10]
-- => [("yksi", 1), ("kaksi", 2), ("kolme", 3)]
-- eripituisilla listoilla ylijaavat alkiot pudotetaan pois
\end{minted}
\label{lst:zip-example}
\caption{Esimerkki \Haskell{zip}-funktion käytöstä}
\end{listing}

\Haskell{zip}-funktion voi yleistää myös mielivaltaiselle määrälle listoja;
esimerkiksi standardikirjaston funktio \Haskell{zip3} ottaa kolme listaa ja tuottaa listan kolmikoita.

\begin{minted}{haskell}
zip  :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
-- jne.
\end{minted}

Funktiot \Haskell{zip} ja \Haskell{zip3} voisi toteuttaa esim. seuraavasti:

\begin{minted}{haskell}
zip l1 l2 = if any [null l1, null l2]
    then []
    else (head l1, head l2) : zip (tail l1) (tail l2)

zip3 l1 l2 l3 = if any (==True) [null l1, null l2, null l3]
    then []
    else (head l1, head l2, head l3) : zip3 (tail l1) (tail l2) (tail l3)
\end{minted}

\Haskell{any}-funktio tarkistaa päteekö ensimmäisenä parametrinä annettu predikaattifunktio jollekin toisena parametrina annetun listan alkiolle.
\Haskell{null}-funktio kertoo onko parametrinä annettu lista tyhjä.
Siis jos mikä tahansa parametrilistoista on tyhjä, niin \Haskell{zip$N$}-funktion paluuarvo on tyhjä lista,
muulloin luodaan monikko jokaisen parametrilistan ensimmäisestä alkiosta,
ja liitetään se rekursiivisesti tehtyyn \Haskell{zip$N$}-kutsuun loppulistoille.

Ohjelmoijan kannalta olisi ikävää, jos jokainen \Haskell{zip}-variantti pitäisi toteuttaa käsin.
Template Haskellia käyttämällä on kuitenkin mahdollista luoda makro,
jolla \Haskell{zip}-funktioiden luomisen voi automatisoida.

\begin{listing}[H]
    \inputminted{haskell}{codes/zip-generator/MakeZip.hs}
    \label{lst:make-zip}
    \caption{Mielivaltaisen \Haskell{zip$N$}-funktion generoiva Template Haskell-makro}
\end{listing}
