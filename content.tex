\section{Johdanto}
\section{Haskell}
\subsection{Yleistä}
Haskell on staattisesti- ja vahvasti tyypitetty laiska, puhtaasti funktionaalinen ohjelmointikieli.

Haskell-kielen suunnittelu ja kehitys alkoi vuonna 1987,
jolloin päämääränä oli tuoda lukuisten, hyvin samankaltaisten laiskojen puhtaasti funktionaalisten tutkimuskielien ideat yhteen.
Tällä hetkellä kielen uusin spesifikaatio ``Haskell Language Report'' on vuodelta 2010.~\cite{HaskellReport2010}.

Aktiivisesti kehitettyjä sekä ajantasaisia Haskell-kääntäjiä on käytännössä ainoastaan
GHC, Glasgow Haskell Compiler~\cite{GHC}.
Itse kielen käyttäjiä varten julkaistaan säännöllisesti Linux-, Windows- ja
Mac OS X-käyttöjärjestelmille  jakelupaketti ``Haskell Platform''~\cite{HaskellPlatform},
joka sisältää GHC:n lisäksi kirjastoja esimerkiksi yksikkötestaukseen, POSIX-rajapintoihin
sekä OpenGL:ään.

\subsection{Syntaksi ja määrittelyt}
\subsection{Sisäänrakennetut tyypit}
\subsection{Kontrollirakenteet}
\subsection{Omien tyyppien määrittely}
\subsection{Tyyppiluokat}

\section{Metaohjelmointi Haskellilla}
\subsection{Template Haskell}

Template Haskell~\cite{ThPaper} on GHC-kääntäjän toteuttama epävirallinen laajennos Haskell-kieleen,
joka tarjoaa mahdollisuudet käännösaikaiseen metaohjelmointiin makrojen muodossa.

Makrojärjestelmät voidaan karkeasti jakaa tekstuaalisiin makroihin sekä syntaktisiin makroihin.
Tunnetuimpia esimerkkejä tekstuaalisista makroista on C-kielen esikääntäjä sekä erinäisten assemblereiden makrokielet,
kun taas syntaktiset makrot ovat Lisp-kieliperheen tavaramerkki.
Template Haskellin tarjoamat makrot lukeutuvat näistä kategorioista jälkimmäiseen:
Template Haskell-makrot ovat tavallisia Haskell-funktioita,
joilla on paluutyyppinä Template Haskell-kirjastossa määritelty syntaksipuutyyppi.

\subsection{Template Haskell-esimerkki}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/THExample.hs}
    \label{lst:example-definition}
    \caption{\texttt{THExample.hs:} Esimerkki Template Haskell-makrosta}
\end{listing}

\begin{listing}[H]
    \inputminted{haskell}{codes/compile-time-eval-example/Main.hs}
    \label{lst:example-usage}
    \caption{\texttt{Main.hs:} Esimerkki edeltävän makron käytöstä}
\end{listing}

Listauksessa \ref{lst:example-definition} määritellään makro \Haskell{compileTimeEval},
jonka avulla voidaan tehdä laskutoimituksia käännösaikana.
Huomattavaa on, että koko kyseinen moduuli on aivan standardia Haskell 2010-koodia,
ja että \Haskell{compileTimeEval} on vain tavallinen Haskell-funktio,
jonka paluutyyppinä sattuu olemaan \Haskell{Q Exp}.

Listauksessa \ref{lst:example-usage} esitellään \Haskell{compileTimeEval}-makron käyttöä,
määrittelemällä nimet \Haskell{foo} ja \Haskell{bar} sen avulla.
Makron käyttö tapahtuu dollarimerkkisyntaksilla \Haskell{\$(\emph{lauseke})},
jossa \emph{lauseke} voi olla mielivaltaista Haskell-koodia.
Koska dollarisyntaksi ja Template Haskell itsessään ei kuulu Haskell 2010-standardiin,
on moduulin alkuun täytynyt laittaa pragma \Haskell{\{-\# LANGUAGE TemplateHaskell \#-\}}
Template Haskell-laajennoksen sallimiseksi.

Kääntäessä \Haskell{Main.hs}-moduulia voidaan havaita,
että \Haskell{\$(compileTimeEval ...)}-lausekkeiden arvot todella lasketaan käännösaikana:
ensin useita sekunteja kuluu lukujen 1--10 000 000 summan laskemiseen,
sitten käännös päättyy virheeseen,
koska makroekspansion aikana jaettiin nollalla.
Siis \Haskell{\$()}-rakenteen sisällä oleva lauseke suoritetaan käännösaikana,
ja sen paluuarvona oleva syntaksipuu (tyyppiä \Haskell{Q Exp}) liitetään käännettävän moduulin
syntaksipuuhun.
Template Haskellin moduuli \Haskell{Language.Haskell.TH.Syntax} tarjoaa tyypit \Haskell{Exp},
joka vastaa Haskellin lausekkeen syntaksipuun tyyppiä,
sekä tyypin \Haskell{Q},
joka on \Haskell{IO}-tyyppiin verrattavissa oleva monadityyppi.
Moduulista \Haskell{Language.Haskell.TH.Lib} löytyvät apufunktiot \Haskell{litE :: Lit -> Q Exp}
sekä \Haskell{litE :: Integer -> Lit},
joiden avulla luodaan kokonaislukuliteraalia vastaava syntaksipuun lehtisolmu.

\subsection{Syntaksipuu}
Koska Template Haskell-makrojen pääasiallinen tavoite on tuottaa koodia syntaksipuun muodossa,
on syntaksipuuta vastaavat Haskell-tietorakenteet erittäin keskeisessä osassa.
Kyseiset tietotyypit löytyvät kirjastomoduulista \Haskell{Language.Haskell.TH.Syntax}.

Tyyppi \Haskell{Exp} vastaa Haskell-lausekkeen syntaksipuuta.

\begin{minted}{haskell}
data Exp
  = VarE Name                          -- viittaus arvon nimeen, esim. foo
  | ConE Name                          -- viittaus tyyppikonstruktorin nimeen, esim. True
  | LitE Lit                           -- vakio, esim. 'a', 42 tai "mjono"
  | AppE Exp Exp                       -- funktiokutsu, esim. f x

  | InfixE (Maybe Exp) Exp (Maybe Exp) -- operaattorin kutsu tai osittainsovellus, esim:
                                       -- a + b, (+b), (a+)

  | UInfixE Exp Exp Exp                -- ???

  | ParensE Exp                        -- lauseke suluissa, esim. (x)
  | LamE [Pat] Exp                     -- lambdafunktio, \ p1 p2 -> e
  | LamCaseE [Match]                   -- case m1; m2
  | TupE [Exp]                         -- monikon muodostus, esim. (e1, e2)
  | CondE Exp Exp Exp                  -- ehtolauseke, if e1 then e2 else e3
  | LetE [Dec] Exp                     -- sitomislauseke let x=e1; y=e2 in e3
  | CaseE Exp [Match]                  -- case-lauseke: case e of m1; m2
  | DoE [Stmt]                         -- do-lauseke: do { p <- e1; e2 }
  | CompE [Stmt]                       -- ei kasitella!!! @{ [ (x,y) | x <- xs, y <- ys ] }@

  | ArithSeqE Range                    -- ei kasitella!!! @{ [ 1 ,2 .. 10 ] }@
  | ListE [Exp]                        -- lista [e1, e2, e3]
  | SigE Exp Type                      -- ei kasitella!!! @{ e :: t }@
  | RecConE Name [FieldExp]            -- ei kasitella!!! @{ T { x = y, z = w } }@
  | RecUpdE Exp [FieldExp]             -- ei kasitella!!! @{ (f x) { z = w } }@
  deriving( Show, Eq, Data, Typeable )
\end{minted}
